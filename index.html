<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<title>大老二</title>
<style>
    :root {
        --card-w: 9vmin;
        --card-h: 12.6vmin;
        --font-rank: 2.8vmin;
        --font-suit: 2.5vmin;
        --font-center: 6vmin;
        --btn-padding: 1.5vmin 3vmin;
    }

    body { 
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
        background-color: #2E8B57; 
        color: white; 
        margin: 0; 
        overflow: hidden; 
        user-select: none; 
        width: 100vw; 
        height: 100vh;
        padding-top: env(safe-area-inset-top);
        padding-bottom: env(safe-area-inset-bottom);
        position: relative;
    }
    
    #setup-screen { 
        position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
        background-color: #1e5c39; 
        z-index: 9999; 
        display: flex; flex-direction: column; justify-content: center; align-items: center; 
    }
    
    #effects-layer { 
        position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
        pointer-events: none; z-index: 100; overflow: hidden; 
    }
    
    .btn { 
        padding: var(--btn-padding); 
        font-size: 2.5vmin; 
        cursor: pointer; 
        background: #FFD700; border: none; border-radius: 1vmin; 
        margin: 1vmin; font-weight: bold; color: #333; 
        transition: 0.2s; min-width: 15vmin; 
        box-shadow: 0 0.5vmin 1vmin rgba(0,0,0,0.3); 
        touch-action: manipulation;
    }
    .btn:hover { background: #FFC107; transform: translateY(-0.5vmin); }
    .btn:disabled { background: #ccc; color: #666; cursor: not-allowed; transform: none; box-shadow: none; }
    
    #game-board { width: 100%; height: 100%; position: relative; display: none; }
    
    .player-area { 
        position: absolute; 
        display: flex; justify-content: center; align-items: center; 
        pointer-events: none; 
    }
    .hand-container { 
        display: flex; justify-content: center; align-items: flex-end; 
        pointer-events: auto; 
    }
    
    /* === 佈局微調區 === */

    /* P0 (自己): 維持 15% */
    #p0 { bottom: 15%; left: 50%; transform: translateX(-50%); width: 95%; height: 20%; z-index: 10; align-items: flex-end; } 
    
    /* P1 (右 - 單眼佬): 拉寬到 6% (原本 12%) */
    #p1 { right: 6%; top: 50%; transform: translateY(-50%) rotate(-90deg); z-index: 5; }
    
    /* P2 (上 - 刀仔): 稍微調高到 2% (原本 5%) */
    #p2 { top: 2%; left: 50%; transform: translateX(-50%) rotate(180deg); z-index: 5; }
    
    /* P3 (左 - 星仔): 拉寬到 6% (原本 12%) */
    #p3 { left: 6%; top: 50%; transform: translateY(-50%) rotate(90deg); z-index: 5; }
    
    /* === 卡牌樣式 === */
    .card { 
        width: var(--card-w); height: var(--card-h); 
        background: white; border-radius: 1vmin; 
        border: 1px solid #999; 
        margin-left: calc(var(--card-w) * -0.6); 
        position: relative; cursor: pointer; 
        box-shadow: 0.2vmin 0.2vmin 0.5vmin rgba(0,0,0,0.4); 
        transition: transform 0.2s; color: black; 
        display: block; 
        padding: 0.5vmin;
        box-sizing: border-box; 
    }
    .card:first-child { margin-left: 0; }
    .card.selected { transform: translateY(-4vmin); border: 0.3vmin solid gold; box-shadow: 0 0 2vmin gold; }
    .card.red { color: #d40000; }
    .card.black { color: #000; }
    .card-back { background: repeating-linear-gradient(45deg, #3b4ba5, #3b4ba5 1vmin, #2a3575 1vmin, #2a3575 2vmin); border: 0.2vmin solid #ddd; }
    
    .card-corner {
        position: absolute; display: flex; flex-direction: column;
        align-items: center; line-height: 0.9; font-weight: bold; width: 3vmin;
    }
    .corner-top { top: 0.5vmin; left: 0.5vmin; }
    .corner-bottom { bottom: 0.5vmin; right: 0.5vmin; transform: rotate(180deg); }
    
    .rank-text { font-size: var(--font-rank); letter-spacing: -0.2vmin; }
    .suit-text { font-size: var(--font-suit); margin-top: -0.1vmin; }
    
    .card-center {
        position: absolute; top: 50%; left: 50%;
        transform: translate(-50%, -50%); font-size: var(--font-center);
    }

    .warning { animation: pulseRed 1.5s infinite; }
    @keyframes pulseRed { 0% { box-shadow: 0 0 0 rgba(255,0,0,0); } 50% { box-shadow: 0 0 3vmin red; } 100% { box-shadow: 0 0 0 rgba(255,0,0,0); } }
    
    /* 中央出牌區 */
    #center-area { 
        position: absolute; top: 50%; left: 50%; 
        transform: translate(-50%, -50%); 
        width: 60%; height: 20%; 
        display: flex; justify-content: center; align-items: center; 
        z-index: 1; 
    }
    .played-card { margin-left: calc(var(--card-w) * -0.65); transform: scale(0.9); pointer-events: none; box-shadow: -0.5vmin 0 1vmin rgba(0,0,0,0.2); }
    
    /* 控制區 */
    #controls { 
        position: absolute; bottom: 32%; 
        left: 50%; 
        transform: translateX(-50%); 
        display: flex; gap: 1.5vmin; 
        z-index: 30; 
    }
    
    /* 狀態訊息 */
    #status-msg { 
        position: absolute; top: 30%; left: 50%; 
        transform: translate(-50%, -50%); 
        font-size: 3vmin; text-shadow: 1px 1px 3px black; 
        background: rgba(0,0,0,0.7); 
        padding: 1vmin 3vmin; border-radius: 5vmin; 
        pointer-events: none; color: #fff; 
        border: 1px solid rgba(255,255,255,0.3); 
        transition: all 0.3s; z-index: 150; 
        white-space: nowrap;
    }
    
    /* 計時器 (右下) */
    #timer-display {
        position: absolute; bottom: 5%; right: 5%;
        font-size: 8vmin; font-weight: 900; 
        color: rgba(255,255,255,0.3); 
        z-index: 0; pointer-events: none;
        transition: color 0.3s;
    }
    .timer-urgent { 
        color: #ff3333 !important; 
        text-shadow: 0 0 2vmin rgba(255, 0, 0, 0.5);
        animation: blinkTimer 0.5s infinite; 
    }
    @keyframes blinkTimer { 50% { opacity: 0.5; } }

    /* === 名字標籤 === */
    .name-tag { 
        position: absolute; background: rgba(0,0,0,0.85); 
        padding: 0.8vmin 2vmin; border-radius: 1vmin; 
        font-size: 2.2vmin; color: white; white-space: nowrap; 
        font-weight: bold; border: 1px solid #777; 
        z-index: 50; 
        box-shadow: 0 0 1vmin rgba(0,0,0,0.5);
    }

    #p0 .name-tag { top: auto; bottom: -8vmin; }
    
    /* 電腦名字標籤微調 */
    #p1 .name-tag { top: -15vmin; transform: rotate(90deg); }
    #p2 .name-tag { top: -8vmin; bottom: auto; transform: rotate(180deg); }
    #p3 .name-tag { top: -15vmin; transform: rotate(-90deg); }
    
    .last-card-alert { color: #ff3333; font-weight: 900; animation: blink 0.5s infinite; font-size: 1.3em; margin-left: 0.5vmin; }
    @keyframes blink { 50% { opacity: 0; } }

    .pass-text {
        position: fixed; font-size: 8vmin; font-weight: 900; color: #eee;
        text-shadow: 0 0 1vmin #000; pointer-events: none; z-index: 200;
        background: rgba(0,0,0,0.7); padding: 1vmin 4vmin; border-radius: 2vmin;
        border: 0.3vmin solid #aaa; animation: floatUp 0.8s ease-out forwards;
    }
    @keyframes floatUp {
        0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
        20% { transform: translate(-50%, -50%) scale(1.1); opacity: 1; }
        100% { transform: translate(-50%, -150px) scale(1); opacity: 0; }
    }

    h1 { font-size: 8vmin; margin-bottom: 5vmin; text-shadow: 0 0 2vmin #FFD700; color: gold; }
    p { font-size: 3vmin; color: #ddd; }
</style>
</head>
<body>

<div id="setup-screen">
    <h1>大老二</h1>
    <p>請選擇玩家人數：</p>
    <div>
        <button class="btn" onclick="startGame(2)">2 人對戰</button>
        <button class="btn" onclick="startGame(3)">3 人混戰</button>
        <button class="btn" onclick="startGame(4)">4 人標準</button>
    </div>
</div>

<div id="effects-layer"></div>

<div id="game-board">
    <div id="timer-display">20</div>
    <div id="status-msg">等待開始...</div>
    <div id="center-area"></div>
    
    <div id="p0" class="player-area"></div>
    <div id="p1" class="player-area"></div>
    <div id="p2" class="player-area"></div>
    <div id="p3" class="player-area"></div>

    <div id="controls">
        <button class="btn" id="btn-play" onclick="humanPlay()">出牌</button>
        <button class="btn" id="btn-pass" onclick="humanPass()" style="background:#888;">Pass</button>
        <button class="btn" id="btn-sort" onclick="sortHand()" style="background:#20B2AA;">按花色排序</button>
    </div>
</div>

<script>
    const SUITS = ['\u2663', '\u2666', '\u2665', '\u2660']; 
    const RANKS = ['3','4','5','6','7','8','9','10','J','Q','K','A','2'];
    const VALUES = { '3':0, '4':1, '5':2, '6':3, '7':4, '8':5, '9':6, '10':7, 'J':8, 'Q':9, 'K':10, 'A':11, '2':12 };
    const PLAYER_NAMES = ["你", "單眼佬", "刀仔", "星仔"];

    let players = [];
    let numPlayers = 4;
    let currentPlayer = 0;
    let lastPlayedCards = null; 
    let passCount = 0;
    let gameActive = false;
    let isFirstRound = true;
    let startCardValue = -1; 
    let isSuitSort = false;
    let timerInterval = null;
    let timeLeft = 20;

    const AI_BRAIN = {
        tracker: null,
        init: function(totalPlayers, myHand) {
            this.tracker = new CardTracker();
            this.tracker.setMyHand(myHand);
        },
        recordMove: function(playerIdx, cards, pattern) {
            this.tracker.markPlayed(cards);
        },
        calculateRisk: function(myHand, pattern, tracker) {
            const myType = pattern.type;
            let threats = tracker.getUnknownThreats(myType, pattern.val);
            if (threats.length === 0) return 0.0;
            let risk = (threats.length * 1.5) / 10; 
            if (risk > 1.0) risk = 1.0;
            return risk;
        }
    };

    class CardTracker {
        constructor() {
            this.status = new Array(52).fill(0);
        }
        setMyHand(cards) {
            cards.forEach(c => this.status[c.value] = 2);
        }
        markPlayed(cards) {
            cards.forEach(c => this.status[c.value] = 1);
        }
        getUnknownThreats(type, myVal) {
            let threats = [];
            if (type === 'single') {
                for (let v = myVal + 1; v < 52; v++) {
                    if (this.status[v] === 0) threats.push(v);
                }
            } else if (type === 'pair') {
                for (let r = Math.floor(myVal/4) + 1; r <= 12; r++) { 
                    let unknownCount = 0;
                    for (let s=0; s<4; s++) {
                        if (this.status[r*4+s] === 0) unknownCount++;
                    }
                    if (unknownCount >= 2) threats.push(r); 
                }
            }
            return threats;
        }
    }

    class Card {
        constructor(rank, suitIdx) {
            this.rank = rank;
            this.suitIdx = suitIdx; 
            this.value = VALUES[rank] * 4 + suitIdx; 
            this.rankVal = VALUES[rank]; 
            this.selected = false;
        }
        get color() { return (this.suitIdx === 1 || this.suitIdx === 2) ? 'red' : 'black'; }
        get fullName() { return SUITS[this.suitIdx] + this.rank; }
    }

    function startGame(n) {
        numPlayers = n;
        document.getElementById('setup-screen').style.display = 'none';
        document.getElementById('game-board').style.display = 'block';
        initGame();
    }

    function initGame() {
        AI_BRAIN.tracker = new CardTracker(); 
        let deck = [];
        for (let r of RANKS) for (let s = 0; s < 4; s++) deck.push(new Card(r, s));
        for (let i = deck.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [deck[i], deck[j]] = [deck[j], deck[i]];
        }

        players = [];
        for (let i = 0; i < numPlayers; i++) {
            players.push({
                id: i,
                name: PLAYER_NAMES[i],
                hand: [],
                isHuman: i === 0
            });
        }

        for (let i = 0; i < deck.length; i++) {
            if (i >= numPlayers * 13 && numPlayers < 4) break; 
            players[i % numPlayers].hand.push(deck[i]);
        }

        let starter = -1;
        let minVal = 999;
        players.forEach((p, idx) => {
            p.hand.sort((a, b) => a.value - b.value); 
            if (p.hand.length > 0 && p.hand[0].value < minVal) {
                minVal = p.hand[0].value;
                starter = idx;
            }
        });
        
        currentPlayer = starter;
        startCardValue = minVal; 
        lastPlayedCards = null;
        passCount = 0;
        gameActive = true;
        isFirstRound = true;
        isSuitSort = false;
        document.getElementById('btn-sort').innerText = "按花色排序";

        if (players[0].isHuman && players[0].hand[0].value === startCardValue) {
            players[0].hand[0].selected = true;
        }

        renderHands();
        checkTurn();
    }

    function getCardNameByValue(val) {
        let rIdx = Math.floor(val / 4);
        let sIdx = val % 4;
        return SUITS[sIdx] + RANKS[rIdx];
    }

    function startCountdown() {
        stopCountdown(); 
        timeLeft = 20;
        updateTimerDisplay();
        const timerEl = document.getElementById('timer-display');
        timerEl.classList.add('timer-active');
        timerInterval = setInterval(() => {
            timeLeft--;
            updateTimerDisplay();
            if (timeLeft <= 0) handleTimeout();
        }, 1000);
    }

    function stopCountdown() {
        if (timerInterval) clearInterval(timerInterval);
        const timerEl = document.getElementById('timer-display');
        timerEl.classList.remove('timer-active');
        timerEl.classList.remove('timer-urgent');
    }

    function updateTimerDisplay() {
        const el = document.getElementById('timer-display');
        el.innerText = timeLeft;
        if (timeLeft <= 5) el.classList.add('timer-urgent');
        else el.classList.remove('timer-urgent');
    }

    function handleTimeout() {
        stopCountdown();
        const canPass = (lastPlayedCards !== null) && (!isFirstRound);
        if (canPass) {
            updateStatus("時間到！自動 Pass");
            players[0].hand.forEach(c => c.selected = false);
            passTurn();
        } else {
            updateStatus("時間到！強制出牌");
            autoPlayForHuman();
        }
    }

    function autoPlayForHuman() {
        const hand = players[0].hand;
        let cardsToPlay = [];
        if (isFirstRound) {
            let minCard = hand.find(c => c.value === startCardValue);
            cardsToPlay = minCard ? [minCard] : [hand[0]]; 
        } else {
            cardsToPlay = [hand[0]];
        }
        playCards(0, cardsToPlay, analyzePattern(cardsToPlay));
    }

    function renderHands() {
        for (let i = 0; i < 4; i++) {
            const pDiv = document.getElementById(`p${i}`);
            if (i >= numPlayers) { pDiv.innerHTML = ''; continue; }

            const p = players[i];
            let handContainer = pDiv.querySelector('.hand-container');
            let nameTag = pDiv.querySelector('.name-tag');
            
            if (!handContainer) {
                pDiv.innerHTML = '';
                nameTag = document.createElement('div');
                nameTag.className = 'name-tag';
                pDiv.appendChild(nameTag);
                handContainer = document.createElement('div');
                handContainer.className = 'hand-container';
                pDiv.appendChild(handContainer);
            }

            const isLastOne = p.hand.length === 1;
            if (isLastOne) handContainer.classList.add('warning');
            else handContainer.classList.remove('warning');
            
            nameTag.innerHTML = `${p.name} (${p.hand.length}) ${isLastOne ? '<span class="last-card-alert">!</span>' : ''}`;

            let html = '';
            p.hand.forEach(card => {
                if (p.isHuman) {
                    const selClass = card.selected ? 'selected' : '';
                    html += `<div class="card ${card.color} ${selClass}" onclick="toggleSelect(${card.value})">
                                <div class="card-corner corner-top">
                                    <span class="rank-text">${card.rank}</span>
                                    <span class="suit-text">${SUITS[card.suitIdx]}</span>
                                </div>
                                <div class="card-center">${SUITS[card.suitIdx]}</div>
                                <div class="card-corner corner-bottom">
                                    <span class="rank-text">${card.rank}</span>
                                    <span class="suit-text">${SUITS[card.suitIdx]}</span>
                                </div>
                             </div>`;
                } else {
                    html += `<div class="card card-back"></div>`;
                }
            });
            handContainer.innerHTML = html;
        }
        
        const isHumanTurn = (currentPlayer === 0);
        const btnPass = document.getElementById('btn-pass');
        const btnPlay = document.getElementById('btn-play');
        const btnSort = document.getElementById('btn-sort');
        
        btnPlay.style.display = isHumanTurn ? 'block' : 'none';
        btnPass.style.display = isHumanTurn ? 'block' : 'none';
        btnSort.style.display = isHumanTurn ? 'block' : 'none';
        
        if (lastPlayedCards === null || isFirstRound) {
            btnPass.disabled = true;
            btnPass.innerText = "不可 Pass";
            btnPass.style.background = "#555";
        } else {
            btnPass.disabled = false;
            btnPass.innerText = "Pass";
            btnPass.style.background = "#888";
        }
    }

    function sortHand() {
        if (players[0].hand.length === 0) return;
        const btn = document.getElementById('btn-sort');
        isSuitSort = !isSuitSort;

        if (isSuitSort) {
            players[0].hand.sort((a, b) => {
                if (a.suitIdx !== b.suitIdx) return a.suitIdx - b.suitIdx;
                return a.rankVal - b.rankVal;
            });
            btn.innerText = "按點數排序";
            updateStatus("已切換：依照花色排序");
        } else {
            players[0].hand.sort((a, b) => a.value - b.value);
            btn.innerText = "按花色排序";
            updateStatus("已切換：依照點數排序");
        }
        renderHands();
    }

    function toggleSelect(val) {
        if (!gameActive || currentPlayer !== 0) return;
        const card = players[0].hand.find(c => c.value === val);
        if (card) card.selected = !card.selected;
        renderHands();
    }

    function updateStatus(msg) {
        document.getElementById('status-msg').innerText = msg;
    }

    function checkTurn() {
        if (!gameActive) return;
        
        if (players[currentPlayer].isHuman) startCountdown();
        else stopCountdown();

        renderHands(); 
        
        let msg = `輪到 ${players[currentPlayer].name}`;
        if (isFirstRound) msg += ` (必須出 ${getCardNameByValue(startCardValue)})`;
        updateStatus(msg);

        if (!players[currentPlayer].isHuman) {
            let thinkTime = 800 + Math.random() * 700;
            setTimeout(aiSmartTurn, thinkTime);
        }
    }

    function analyzePattern(cards) {
        cards.sort((a, b) => a.value - b.value);
        const len = cards.length;
        const ranks = cards.map(c => c.rankVal);
        
        if (len === 1) return { type: 'single', val: cards[0].value };
        if (len === 2 && ranks[0] === ranks[1]) return { type: 'pair', val: cards[1].value };
        
        if (len === 5) {
            const counts = {};
            ranks.forEach(v => counts[v] = (counts[v] || 0) + 1);
            const vals = Object.values(counts);
            if (vals.includes(3) && vals.includes(2)) { 
                let maxRankVal = 0;
                for (let r in counts) { if (counts[r] === 3) maxRankVal = parseInt(r); }
                return { type: 'fullhouse', val: maxRankVal * 4 + 0 }; 
            }
            let isStraight = true;
            for (let i=0; i<4; i++) {
                if (cards[i+1].rankVal !== cards[i].rankVal + 1) isStraight = false;
            }
            if (isStraight) return { type: 'straight', val: cards[4].value };
        }
        return null;
    }

    function isValidMove(newPat, cards) {
        if (!newPat) return false;
        if (isFirstRound) {
            const playedStartCard = cards.some(c => c.value === startCardValue);
            if (!playedStartCard) return false;
        }
        if (!lastPlayedCards) return true; 
        if (newPat.type !== lastPlayedCards.type) return false; 
        if (newPat.type === 'fullhouse') {
            return Math.floor(newPat.val/4) > Math.floor(lastPlayedCards.val/4);
        }
        return newPat.val > lastPlayedCards.val;
    }

    function playCards(playerIdx, cards, pattern) {
        stopCountdown(); 

        const p = players[playerIdx];
        p.hand = p.hand.filter(c => !cards.includes(c));
        AI_BRAIN.recordMove(playerIdx, cards, pattern);

        const center = document.getElementById('center-area');
        center.innerHTML = '';
        cards.forEach(c => {
            const el = document.createElement('div');
            el.className = `card played-card ${c.color}`;
            el.innerHTML = `
                <div class="card-corner corner-top">
                    <span class="rank-text">${c.rank}</span>
                    <span class="suit-text">${SUITS[c.suitIdx]}</span>
                </div>
                <div class="card-center">${SUITS[c.suitIdx]}</div>
                <div class="card-corner corner-bottom">
                    <span class="rank-text">${c.rank}</span>
                    <span class="suit-text">${SUITS[c.suitIdx]}</span>
                </div>`;
            center.appendChild(el);
        });

        if (p.hand.length === 0) {
            gameActive = false;
            stopCountdown();
            renderHands(); 
            setTimeout(() => {
                alert(`${p.name} 獲勝！`);
                location.reload();
            }, 300);
            return; 
        }

        lastPlayedCards = pattern;
        lastPlayedCards.owner = playerIdx;
        passCount = 0;
        if (isFirstRound) isFirstRound = false;
        nextTurn();
    }

    function passTurn() {
        stopCountdown(); 
        const pDiv = document.getElementById(`p${currentPlayer}`);
        const rect = pDiv.getBoundingClientRect();
        const x = rect.left + rect.width / 2;
        const y = rect.top + rect.height / 2;

        const el = document.createElement('div');
        el.className = 'pass-text';
        el.innerText = "PASS";
        el.style.left = x + 'px';
        el.style.top = y + 'px';
        document.getElementById('effects-layer').appendChild(el);
        setTimeout(() => el.remove(), 1000);

        passCount++;
        if (passCount >= numPlayers - 1) {
            lastPlayedCards = null;
            setTimeout(() => { document.getElementById('center-area').innerHTML = ''; }, 600);
        }
        nextTurn();
    }

    function nextTurn() {
        currentPlayer = (currentPlayer + 1) % numPlayers;
        checkTurn();
    }

    function humanPlay() {
        const selected = players[0].hand.filter(c => c.selected);
        if (selected.length === 0) return;
        const pat = analyzePattern(selected);
        if (isFirstRound) {
            const playedStartCard = selected.some(c => c.value === startCardValue);
            if (!playedStartCard) {
                alert(`開局第一手必須包含 ${getCardNameByValue(startCardValue)}！`);
                return;
            }
        }
        if (isValidMove(pat, selected)) {
            playCards(0, selected, pat);
        } else {
            alert("無效出牌 (牌型不符或太小)");
        }
    }
    
    function humanPass() {
        if (isFirstRound) return;
        if (!lastPlayedCards) return;
        players[0].hand.forEach(c => c.selected = false);
        passTurn();
    }

    function aiSmartTurn() {
        if (!gameActive) return;

        const p = players[currentPlayer];
        const hand = p.hand;
        const nextP = players[(currentPlayer + 1) % numPlayers];
        const isNextLastCard = (nextP.hand.length === 1); 

        const struct = analyzeHandStructure(hand);
        let cardsToPlay = null;

        if (isFirstRound) {
            let startCard = hand.find(c => c.value === startCardValue);
            let fh = struct.fullhouses.find(arr => arr.includes(startCard));
            if (fh) cardsToPlay = fh;
            else {
                let st = struct.straights.find(arr => arr.includes(startCard));
                if (st) cardsToPlay = st;
                else {
                    let pair = struct.pairs.find(arr => arr.includes(startCard));
                    if (pair) cardsToPlay = pair;
                    else cardsToPlay = [startCard];
                }
            }
        }
        else if (!lastPlayedCards) {
            if (struct.fullhouses.length > 0) cardsToPlay = struct.fullhouses[0];
            else if (struct.straights.length > 0) cardsToPlay = struct.straights[0];
            else if (struct.pairs.length > 0) cardsToPlay = struct.pairs[0];
            else if (struct.singles.length > 0) cardsToPlay = [struct.singles[0]];
            else cardsToPlay = [hand[0]];
        }
        else {
            const targetVal = lastPlayedCards.val;
            
            if (lastPlayedCards.type === 'single') {
                if (isNextLastCard) {
                    const maxCard = hand[hand.length - 1]; 
                    if (maxCard.value > targetVal) cardsToPlay = [maxCard];
                } 
                else {
                    let candidates = struct.singles.filter(c => c.value > targetVal);
                    if (candidates.length === 0) {
                        for(let c of hand) if(c.value > targetVal) candidates.push(c);
                    }
                    if (candidates.length > 0) {
                        let bestCand = candidates[0]; 
                        cardsToPlay = [bestCand];
                        if (bestCand.rank === '2' && hand.length > 3 && Math.random() > 0.7) {
                             cardsToPlay = null;
                        }
                    }
                }
            }
            else if (lastPlayedCards.type === 'pair') {
                let candidates = struct.pairs.filter(p => p[1].value > targetVal);
                if (candidates.length > 0) cardsToPlay = candidates[0];
            }
            else if (lastPlayedCards.type === 'fullhouse') {
                let fh = struct.fullhouses.find(f => {
                     let pat = analyzePattern(f);
                     return Math.floor(pat.val/4) > Math.floor(targetVal/4);
                });
                if (fh) cardsToPlay = fh;
            }
             else if (lastPlayedCards.type === 'straight') {
                let st = struct.straights.find(s => s[4].value > targetVal);
                if (st) cardsToPlay = st;
            }
        }

        if (cardsToPlay) {
            playCards(currentPlayer, cardsToPlay, analyzePattern(cardsToPlay));
        } else {
            passTurn();
        }
    }

    function analyzeHandStructure(hand) {
        let h = [...hand].sort((a,b) => a.value - b.value);
        let singles = [];
        let pairs = []; 
        let fullhouses = []; 
        let straights = [];
        let counts = {};
        h.forEach(c => counts[c.rankVal] = (counts[c.rankVal]||0)+1);

        for (let r in counts) {
            if (counts[r] === 3) {
                for (let r2 in counts) {
                    if (r !== r2 && counts[r2] >= 2) {
                         let trio = h.filter(c => c.rankVal == r).slice(0,3);
                         let duo = h.filter(c => c.rankVal == r2).slice(0,2);
                         fullhouses.push(trio.concat(duo));
                    }
                }
            }
        }
        for (let r in counts) {
            if (counts[r] >= 2) {
                let p = h.filter(c => c.rankVal == r).slice(0,2);
                pairs.push(p);
            }
        }
        h.forEach(c => {
            if (counts[c.rankVal] === 1) singles.push(c);
        });
        for (let i=0; i<=h.length-5; i++) {
            let sub = h.slice(i, i+5);
            let isSt = true;
            for(let j=0; j<4; j++) {
                if(sub[j+1].rankVal !== sub[j].rankVal + 1) isSt = false;
            }
            if(isSt) straights.push(sub);
        }
        return { singles, pairs, fullhouses, straights };
    }
</script>
</body>
</html>